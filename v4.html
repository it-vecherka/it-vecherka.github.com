<!DOCTYPE html>
<html>
<head>
  <title>Олимпиада - Вечерний Анахорет™</title>

  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<meta http-equiv="Content-Language" content="en" />
<meta http-equiv="imagetoolbar" content="no" />

<meta name="viewport" content="width = device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable = no" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<link rel="apple-touch-startup-image" href="/startup.png" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="cleartype" content="on" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta http-equiv="Page-Exit" content="progid:DXImageTransform.Microsoft.Fade(Duration=0.2)" />
<meta name="viewport" content="width=device-width,initial-scale=1" />

<meta name="robots" content="all" />

<link rel="copyright" href="" />
<link rel="author" href="" />

  <link rel="shortcut icon" href="/favicon.ico" />
<link rel="icon" type="image/png" href="/favicon.png" />
<link rel="icon" type="image/x-icon" href="/favicon.ico"  />
<link rel="apple-touch-icon" href="/apple-touch-icon-iphone.png" />
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-ipad.png" />
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-iphone4.png" />



  <!--[if IE]>
  <script type="text/javascript">
    //<![CDATA[
    document.createElement('header');
    document.createElement('nav');
    document.createElement('section');
    document.createElement('article');
    document.createElement('author');
    document.createElement('aside');
    document.createElement('footer');
  //]]>
  </script>
<![endif]-->
<style type="text/css">
  header, nav, section, article, aside, footer {
    display: block;
  }
</style>


  <link href="/v4/application.css" media="screen" rel="stylesheet" type="text/css" />
  <meta content="authenticity_token" name="csrf-param" />
<meta content="qlV878vjorhJ0W+GYBwB2QrAchJ/il6JHlq8RCmI2yc=" name="csrf-token" />
  <style media="screen" type="text/css">.introduction {
  float: right;
  width: 75%;
  padding: 1%;
}

.cover {
  max-width: 18%;
  display: inline-block;
  margin: 1%;
}

.left {
  float: left;
  width: 50%;
}

.right {
  float: right;
  width: 50%;
}

.thanks {
  float: left;
  width: 50%;
  border: 1px solid transparent;
  padding: .5%;
  margin: .5%;
}

.item {
  border: 1px solid #f5f5f5;
  padding: 5%;
  margin: 1%;
  background: #ffffff;
  box-shadow: 2px 2px 0 #eaeaea inset, -2px -2px 0 #eaeaea inset;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -o-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
}

.quotes img {
  max-width: 20%;
  float: left;
}

.quotes ul {
  margin-left: 25%;
  padding: 0;
}

.quotes ul li {
  list-style: none;
  padding: 1%;
  border-top: 1px solid #eeeeee;
  font-style: italic;
}

.quotes ul li:first-child {
  border-top: 0;
}


.quotes ul li em {
  display: block;
  text-align: right;
  color: #888888;
  font-style: normal;
}


@media only screen and (max-width: 768px) {

  .introduction {
    float: right;
    width: 70%;
    padding: 1%;
  }

  .cover {
    display: none;
  }

  .item {
    padding: 1em;
    margin: .1%;
  }


  .left, .right {
    width: 100%;
    float: none;
  }

  .thanks {
    width: 100%;
    float: none;
  }

  .warm-up img, .faye img {
    max-width: 50%;
  }

  .faye img {
    float: left;
    margin-right: .5em;
  }

  .qa-community img {
    max-width: 50%;
  }

}


@media only screen and (max-width: 430px) {
.introduction {
  float: none;
  width: 100%;
}

  .item {
    padding: .5em;
  }
}


.no-method-error-inspect blockquote {
  width: 60%;
  margin-left: 40%;
  font-style: italic;
}

code {
  background: #f5facf;
  padding: 1%;
}

.quotes img {
  max-width: 20%;
  float: left;
}

.quotes ul {
  margin-left: 25%;
  padding: 0;
}

.quotes ul li {
  list-style: none;
  padding: 1%;
  border-top: 1px solid #eeeeee;
  font-style: italic;
}

.quotes ul li:first-child {
  border-top: 0;
}


.quotes ul li em {
  display: block;
  text-align: right;
  color: #888888;
  font-style: normal;
}
</style>

</head>
<body>
<div id="container">
  <header>
    <div class="wrapper">
      <a href="/"><img alt="Вечерний Анахорет™" src="/v4/logo.ru.png" title="Вечерний Анахорет™" /></a>
      <small class="issue">Четвертый выпуск
  <div>
    <a href="https://twitter.com/share" class="twitter-share-button" data-text="Наконец-то новый выпуск Вечерки™" data-via="it_vecherka" data-count="none">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
  </div>
</small>

    </div>
  </header>



  <section id="main" role="main">
    <div class="wrapper">
      <a class="cover" href="/v4/cover.png"><img src="/v4/cover.png" alt="" /></a>

<div class="introduction">

<h1>От авторов</h1>

<div>
  <p>Тема сегодняшнего выпуска - винегрет. За прошедшее сто миллионов лет <a href="/v3.html">с предыдущего выпуска</a> появилась Солнечная система, родились и умерли динозавры, появившийся человек стал разумен. Да, выпуска не было очень давно. Да, воды утекло с тех пор много. Ведь бывает так, что идешь по улице, смотришь - мужик лежит на газоне. И сразу закрадываются сомнения - мужик этот пьян просто в стельку, или умер уже давно? И ведь понятно же, что пьян. А вдруг умер? Подойдешь поближе, пересиля себя и стараясь не вдыхать стойкие пары перегара, убедишься в том, что жив еще, скотина, и успокоившись идешь дальше. И этот выпуск, как то дыхание бедняги с газона - неопровержимое доказательство того, что газета снова в строю.</p>

</div>

<a href="/v4/v4-introduction.html" class="comment_link"><span>Comments</span></a>
</div>

<div class="clearfix"></div>

<div class="left">
  <div class="item">

<h1>Шеф, два счетчика!</h1>

<div>
  <p>Привет, я довольно давно использую <a href="http://www.opscode.com/chef/">opscode chef</a> для настройки и поддержки инфраструктуры и предлагаю использовать его всем. Недавно для одного из своих проектов я собрал инcтрумент для настройки и <strong>поддержки</strong> (это очень важное слово) инфраструктуры и решил выделить его в отдельный проект - <a href="https://github.com/iafonov/stacker">stacker</a>. Я думаю что этот инструмент был бы более чем полезен - каждый проект начинается с ритуала - настройка стейджинга/продакшна. При всей кажущейся простоте настройка сервера и автоматизированного деплоя в зависимости от опыта может занимать от нескольких часов до нескольких дней - это грустно. Особенно это грустно с учетом того, что действия производятся одни и те же (с минимальными вариациями).</p>

<p>Stacker позволяет за минимальное время собрать более-менее идиоматичный стек для rails приложения - nginx + unicorn + PostgreSQL. На данном этапе инструмент уже работает, и им можно пользоваться/тренироваться пользоваться. Как уже замечено выше - очень важная особенность это то, что инструмент предназначен не только для бутстрапа, но и для поддержки инфраструктуры. С помощью изменения атрибутов и добавления новых <a href="http://wiki.opscode.com/display/chef/Cookbooks">кукбуков</a> можно очень легко добавлять/убирать пакеты, изменять конфиги и хранить полное описание инфраструктуры в репозитарии - что позволяет с легкостью переносить приложения на новые сервера и клонировать инфраструктуру. Чтобы понять масштабы уже проделанной кем-то работы - ознакомьтесь со <a href="https://github.com/opscode-cookbooks">списком официально поддерживаемых кукбуков</a> также существует более 9000 неофициальных кукбуков.</p>

<p>По своей сути проект является стандартным <a href="http://wiki.opscode.com/display/chef/Chef+Repository">репозитарием шефа</a> с добавленными наиболее часто используемыми инструментами и ролями. Проект также снабжен максимально полной документацией с помощью которой можно довольно легко начать использовать шеф.</p>

<p>Предполагаемый роадмэп на ближайшее будущее:</p>

<ul>
<li>Еще больше документации</li>
<li>Сделать пример для django/clojure или чего небудь еще не из мира руби</li>
</ul>

<p>Если есть желание можете пробовать/тестировать/вносить изменения - буду рад любым отзывам. <a href="https://github.com/iafonov/stacker">Проект на гитхабе</a></p>

</div>

<a href="/v4/stacker.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Сто свечей</h1>

<div>
  <p>Задача сегодняшней разминки от нашего постоянного читателя Владимира К.</p>

<p><img src="http://i.minus.com/jrlgINk4rW7sW_xs.jpg" alt=""><br>
</p>
<blockquote>
<p>В туннеле стоят одна за другой 100 свечей.<br>
Туннель пробегают в одном направлении один за другим 100 гномов. Каждый гном меняет состояние тех (и только тех) свечей, порядковые номера которых кратны порядковому номеру данного гнома. Свеча может иметь только два состояния: &quot;горит&quot; / &quot;не горит&quot;. В начале процесса все свечи не горят.</p>

<p>Какие свечи останутся гореть когда через туннель пробегут все гномы?</p>
</blockquote>
</div>

<a href="/v4/one-hundred-candles.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Сумма двух</h1>

<div>
  <p><img src="http://i.minus.com/ibp5hE4v4bWilJ.jpeg" alt=""><br>
</p>

<p>А вот и давно обещанная следующая разминка. Мы получили массу удовольствия ища решение этой задачи, и не можем не поделиться.</p>

<p><em>Дано</em>: массив случайных натуральных чисел <code>X</code> в случайном порядке, среди которых могут быть дубликаты. Целое число <code>C</code>.</p>

<p><em>Вопрос</em>: может ли число <code>C</code> быть сформировано суммой двух элементов массива? Другими словами, существуют ли такие <code>i</code>, <code>j</code>, что <code>X[i]</code> + <code>X[j]</code> == <code>C</code>? </p>

<p>Очевидным способом ответ ищется за <code>O(n^2)</code>. Требуется найти более быстрое асимптотически решение. Исходный массив (<code>X</code>) записан в файл построчно, целевая сумма (<code>C</code>) либо передаётся параметром, либо жёстко забита в код, если ваш язык реализации не умеет читать параметры.</p>

<p>В помощь вам <a href="https://gist.github.com/7767503ce37e68941ebc">специально подготовленный гист</a>, в котором есть файлик на 100 000 чисел и перечислено несколько тестовых чисел с правильными ответами - тут можно проверять решение. Можно <a href="https://gist.github.com/gists/7767503ce37e68941ebc/download">сразу скачать</a>. Кстати, квадратичные решения на 100 000 на моём компьютере в Руби работают порядка 40 минут, так что стимул решить правильно вроде бы есть.</p>

<p>Решения оставляйте гистами, комментарий в эту статью или в гист. Просьба к решению прилагать команду для его запуска, типа <code>ruby solution.rb 215500</code> или <code>sbcl --script kuteiko.lisp 66613</code>. Итоги будем подводить через неделю, в понедельник.</p>

<p>Мы приветствуем все решения, но людей из списка просим предоставить свои решения аккурат в следующий понедельник. До этого, пожалуйста, не портите другим программистам удовольствие. Можете просто отметиться в комментариях к этой статье, что, мол, решение есть. В понедельник мы напомним вам, что нужно решением поделиться. Эти люди: Андрей Кутейко, Сергей Качан, Саша Михальчук, Игорь Афонов, Павел Митин, Владимир Коварский. Всем остальным рекомендуем выкладывать решения сразу, чтобы спровоцировать обсуждение достоинств и недостатков и оживить программистскую мысль нашего коллектива. </p>

<p>Желаем всем удачи и хорошего развлечения!</p>

<p>Всегда ваши,<br>
Дима, Лёша.</p>

</div>

<a href="/v4/warm-up-sum-of-two.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Поиск единомышленников</h1>

<div>
  <p>Очередная разминка с лёгким превышением заявленного срока.</p>

<p><em>Задача</em>: найти количество инверсий в перестановке.</p>

<p>Дан массив чисел от 1 до n в случайном порядке. Числа не повторяются. Найти число инверсий в этом массиве. Инверсия - это пара чисел, стоящих в убывающем порядке, когда большее предшествует меньшему. Обращаю внимание, что пара чисел, не обязательно стоящих в массиве подряд. То есть, если к упорядоченному массиву дописать в начало число, которое больше всех элементов массива, оно породоит n-1 инверсию.</p>

<p><em>Формальное определение</em>: в массиве <code>A</code> инверсией считаем пару чисел <code>i</code>,<code>j</code>, где <code>i &lt; j</code>, такие, что <code>A[i] &gt; A[j]</code>.</p>

<p>Соответственно, максимальное количество инверсий будет наблюдаться в массиве, отсортированном в обратном порядке, и это число <code>n(n-1)/2</code>.</p>

<p>Вот для затравки интересный графический алгоритм для поиска инверсий:</p>

<p><img src="http://i.minus.com/ixqwHDi3yD5ZP.png" alt=""><br>
</p>

<p>Мы располагаем исходный массив и сортированный рядом, соединяем одинаковые числа и количество пересечений - это количество инверсий, а сами пересения - это и есть инверсии.</p>

<p><em>Актуальность задачи</em>: Кроме разминки, это можно использовать для определения количественной меры похожести двух списков. Например, приняв один из них за &quot;правильный порядок&quot;, посчитать количество инверсий во втором, относительно первого. Это, в свою очередь, можно использовать для модной нынче штуки, под названием коллективная фильтрация - на основании похожести ваших оценок товаров, фильмов, книг оценкам других пользователей того или иного сервиса предлагать вам товары, фильмы, книги, которые выбрали &quot;похожие&quot; на вас люди.</p>

<p>Для удобства проверки вот вам <a href="https://gist.github.com/gists/3001586/download">одна перестановка с правильным ответом</a>.</p>

<p>Очевидный, или наивный алгоритм, даёт <code>O(n^2)</code>. На среднем компьютере - 40 минут для 100000 чисел.. Хорошие решения дают на том же объёме данных не превышают три секунды.</p>

<p><em>Задача со звёздочкой</em>: как поведёт себя ваше решение, если это не перестановка, а массив случайных чисел, то есть, если в массиве есть дубликаты? Есть ли более эффективные решениия именно для массива без дубликатов, которые на массиве с повторяющимися числами не будут работать или деградируют до квадрата?</p>

<p>Удачи!</p>

</div>

<a href="/v4/warm-up-inversions.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Итоги поиска единомышленников</h1>

<div>
  <p><a href="http://vecherka.cssum.net/v4/warm-up-inversions.html">Последняя разминка о количестве инверсий в массиве</a> торжественно объявляется самой плодотворной.</p>

<p><img src="http://i.minus.com/jnZIGmGVgxY5l.jpg" alt=""><br>
</p>

<p>Первым представил свое решение <a href="https://gist.github.com/raven29">Владимир Львович</a>, решив задачу на руби с использованием дерева Фенвика. И не просто решил, а еще и обобщил задачу до решения с целыми и действительными числами. В итоге Львович предоставил нам три реализации своего алгоритма.</p>

<p>Вторым хочется отметить <a href="http://www.youtube.com/watch?v=rgX4DMmRUMg">решение Дмитрия Кириенко</a>, предствленное в необычном для разминки формате скринкаста. В процессе решения задачи Дмитрий параллельно расказывает о множестве мелких и приятных дополнений не только о решении задачи. Видео рекомендуется к просмотру.</p>

<p>Последнее по счету, но никак не последнее по важности идет, вдохновленное скринкастом Дмитрия, <a href="http://bronislav.github.com/">решение Антон Ильина</a> с текстовым отчетом о проделанной работе <a href="http://bronislav.github.com/blog/2012/06/30/poisk-iedinomyshliennikov-ili-podschiet-kolichiestva-inviersii-v-massivie-tsielykh-chisiel/">у себя в блоге</a>. Статья обязательна к прочтению всем интерисующимся. Антон рассказывает нам об этой новой структуре данных - дерева Фенвика. Новую с точки зрения открытия - Питер Фенвик придумал эту структуру в 1994 году, что, согласитесь, совершенно недавно.</p>

<p>В итоге сложность решения задачи была сведена к <code>O(N*log(N))</code> во всех решениях.</p>

<pre><code>
raven29-int.rb    0.762s
raven29-real.rb   1.213s
bronislav.rb      0.688s
donal.rb          1.106s

</code></pre>

</div>

<a href="/v4/warm-up-inversions-report.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Сто мудрецов</h1>

<div>
  <p><img src="http://i.minus.com/jbwQ8Z6puXpLXz.jpg" alt=""><br>
</p>

<p>Что мы все о программировании да о программировании. Давайте в этот раз просто подумаем и поможем ста мудрецам спастить от неминуемой гибели от рук палача.</p>

<p>Итак, все сто мудрецов выстроены в одну колонну  (каждый видит тех и только тех, кто стоит перед ним), и на головы им будут надеты шляпы одного из <code>k &gt; 0</code> цветов, выбранных независимо и случайным образом. Каждый из мудрецов в колонне, начиная с последнего, должен будет либо назвать цвет своей шляпы, либо сказать «пас».</p>

<p>Мудрецы считаются прошедшими тест, если хотя бы один из них назовёт цвет верно и не будет никого, кто назвал цвет неверно.</p>

<p><em>Вопрос</em>: как должны договориться мудрецы между собой до испытания, чтобы максимизировать вероятность успеха? И какова эта вероятность? Естественно, нельзя ориентироваться ни на какие дополнительные данные (высота голоса ранее ответивших, интервал времени перед ответом и т.д.), решаем честно :)</p>

<p>Для случая <code>k = 1</code> всё достаточно просто: если известно, что шляпы бывают только одного цвета, то именно его надо называть. С вероятностью 100% ответ будет правильным, поэтому мудрецы пройдут тест. </p>

<p>Чем хороша эта задача? А тем, что кажется, что она не имеет разумного решения. Судите сами: первый отвечающий, который видит перед собой 99 шляп, ничего не знает о цвете своей шляпы. Поэтому он, не имея права назвать какой-то цвет (если назовёт, то с вероятностью 1-1/k все проиграют), вынужден сказать «пас». Но у второго совершенно такая же ситуация: он видит перед собой 98 шляп, он заранее знал, что первый скажет «пас», поэтому он тоже вынужден говорить «пас». И так далее. Возникает иллюзия, что выиграть невозможно. И тем интереснее догадаться, как же действовать мудрецам.</p>

<p><strong>UPD</strong>: спойлеры в каментах!</p>

</div>

<a href="/v4/unlikely-event.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Книги новичкам рельсов</h1>

<div>
  <p>Эта заметка относится к Rails разработчикам, друзьям Rails разработчиков, тем, кто собирается предлагать молодёжи Rails для изучения... Собственно, больше всего относится к тем, кто собирается помогать кому бы то ни было учить Рельсы.</p>

<p>Есть такая книга - замечательная книга - <a href="http://pragprog.com/book/rails4/agile-web-development-with-rails">Agile Web Development with Rails</a>. &quot;Гибкая разработка приложений в среде Rails&quot;. Я начинал с неё и подозреваю, что очень сильно в этом не одинок. Книга хорошо и глубоко рассказывает не только о рельсах, но и о веб-разработке, гибкой разработке с участием заказчика в процессе и даёт довольно крепкий фундамент с серьёзным <em>пониманием</em> среды Ruby on Rails.</p>

<p>С некоторых пор стало популярным рекомендовать новичкам книгу <a href="http://ruby.railstutorial.org/chapters/beginning">Майкла Хартла &quot;Ruby on Rails tutorial&quot;</a>. И я рекомендовал, и вслед за мной многие другие рекомендовали. К сожалению, эта книга даёт гораздо более грустные результаты. В ней читателя подводят к использованию огромного количества бестий из околорельсовского зоопарка, предлагают писать довольно гадкий код и практически не отвечают ни на один из вопросов &quot;как это работает&quot; или &quot;зачем это надо&quot;. Собственно, первое соображение хуже всего. Rvm, Rbenv, RSpec, Spork, Guard, Autotest-Growl, Gravatar, Heroku - всё это очень сильно отвлекает неофита от навыка написания моделей, контроллеров и представлений, и тем более от попыток понять, как и почему всё так устроено.</p>

<p>Поэтому я настоятельно рекомендую не рекомендовать молодым адептам книгу Rails tutorial как не приносящую положительных результатов. На Озоне есть четвёртое издание на русском языке в, как говорят, отличном переводе, обновлённое до Rails 3.1. Это могло бы пригодиться многим и многим начинающим разработчикам.</p>

</div>

<a href="/v4/agile-web-development-with-rails.html" class="comment_link"><span>Comments</span></a>
</div>
</div>

<div class="right">
  <div class="item no-method-error-inspect">

<h1>Обыкновенная современная трагедия</h1>

<div>
  <blockquote>
<p>Я тоже физику не люблю, перестал её любить еще в восьмом классе, когда мне сказали, что если я обойду с мешком картошки на плече вокруг школы пять раз, то совершенная мною работа будет равна нулю...<br>
<a href="http://bash.im/quote/406812">Баш</a>.</p>
</blockquote>
<p>Сделал только что интересное открытие. Если бы я был компьютером, после этого открытия я бы поднял восстание машин.</p>

<p>Не знаю, заметили ли вы, но с некоторого момента NameError и NoMethodError (&quot;неизвестная переменная или метод&quot; или &quot;неизвестный метод&quot;) во вью в рельсах стали ОЧЕНЬ сильно замедлять систему. Если посмотреть на загрузку системы в этот момент, мы увидим 100% загрузку процессора, а страничка с ошибкой и запись в лог произойдёт спустя 60-80 секунд. Знакомо? Встречается, начиная с 3.1.rc1 и не было исправлено ни в 3.1-stable, ни в 3.2-stable. На сегодняшний день в 3.2.2 (последная стабильная версия) это всё ещё не исправлено.</p>

<p>Что же происходит?</p>

<p><code>Rails.application.routes.inspect.size # =&gt; 3114195 в нашем приложении.</code></p>

<p>Строка на три миллиона символов.</p>

<p>Проблема пришла откуда не ждали. Внутри руби есть такой <code>name_err_mesg_to_str</code>, который всегда вызывает inspect обрабатывая NameError и NoMethodError, на том объекте, на котором не нашли метода.</p>

<p>Соответственно, если вы пишете во вью &lt;%= bad_method_name &gt;, у вас вызывается inspect на ActionView::Base. Реализация inspect в классе Object такова, что он рекурсивно вызывает inspect на всех переменных экземпляра. В результате конструируется феерической длины строка, её конструирование съедает 100% процессора и тьму тьмущую памяти (из-за того, что inspect на RouteSet, к примеру, этот метод при возникновении ошибки вызывается 7 раз). На живом сервере это, при конкурентных запросах ещё приводит к свопу. Да и вообще - для того, чтобы полностью занять делом ваш 4-х ядерный процессор достаточно 4-х пользователей, одновременно поймавших NameError во вью.</p>

<p>И совершенно неважно, что в продакшен режиме вы не рисуете красивую и подробную страничку ошибки, а мгновенно отдаёте 500.html через Апач. Ещё до того, как Рельсы осознали, что что-то пошло не так, Руби генерирует вам многомегабайтные строки, которые никто никогда не прочитает.</p>

<p>8 месяцев тысячи Rails приложений при ошибках загружали на 100% на минуту-две процессор, генерируя десятки миллионов никому не нужных ActiveSupport::Multibyte и это ужасно.</p>

<p>В общем, обновляйтесь до &gt;= 3.2.3 срочно. Есть &quot;исправляющий&quot; коммит.</p>

</div>

<a href="/v4/no-method-error-inspect.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Харьковский хакатон</h1>

<div>
  <p>В конце июня донецкая делегация приняла участие в очередном <a href="http://dou.ua/calendar/1952/">DOU хакатоне</a>, который проходил в городе Харькове. Наш город был представлен четырьмя программистами.</p>

<p><a href="http://litovchenko.com/blog/">Александр</a>, <a href="http://andy128k.blogspot.com/">Андрей</a> и <a href="http://vk.com/dennytwix">Ден</a> выдали на-гора CL realtime server -- аналог Apple Game Kit. В те 24 часа, которые были отпущены на проект, ребята успели создать клиентские библиотеки под iOS и под мак. В планах - охватить андроид и другие популярные платформы. Ребята выбрали, в качестве основы проекта, сервер <a href="https://github.com/3b/clws">clws</a></p>

<p><a href="http://novembermeeting.blogspot.com/">Павел Митин</a> написал минималистичный <a href="https://github.com/MitinPavel/current_user">аутентификационный гем для Ruby On Rails</a>, который применяется до момента запуска проекта в продакшен.</p>

<p>Принимающая сторона сделала все, чтобы у гостей и участников остались только положительные воспоминания. Одно только присутствие в здании восточного ресторана чего стоит! Победили в соревнованиии замечательная пара (муж и жена), которые написали mongo-подобную базу данных на основе файловой системы в пользовательском пространстве [<a href="https://github.com/silver-/mongo-fuse">https://github.com/silver-/mongo-fuse</a>]</p>

<p>Несомненно хакатон удался: от марафонского кодирования, до задушевных песен под гитару и спортивных баталий. Если вы еще ни разу не участвывали в хакатоне, обязательно это сделайте!</p>

</div>

<a href="/v4/kharkov-hackathon.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>ActiveRecord и валидация на уникальность</h1>

<div>
  <p>Кто знает - напоминаю, кто не знает - сообщаю: валидация в ActiveRecord на уникальность не гарантирует уникальности. Как она работает - делает запрос в базу данных на предмет &quot;а есть ли уже запись с таким значением&quot;, а при получении отрицательного ответа - ничтоже сумняшеся начинает сохранять. Если в этот момент в базе запись-таки появится - будет нарушение уникальности.</p>

<p>Если вы думаете, что это не про вас, и у вас в приложении полтора пользователя, а нагрузка для этого эффекта нужна посерьёзнее - вы заблуждаетесь, и заряженный арбалет уже нацелен на ваше колено. <a href="http://lurkmore.to/Skyrim#.D0.A1.D1.82.D1.80.D0.B5.D0.BB.D0.B0_.D0.B2_.D0.BA.D0.BE.D0.BB.D0.B5.D0.BD.D0.B5">Мы вот тоже думали, что это не про нас, но...</a></p>

<p>Гарантию уникальности даст индекс с проверкой уникальности. Но он не дёргает ошибку валидации.</p>

<p>Я тут немного поговнокодил и сделал drop-in решение, простое, как стол - если сохранение падает по причине нарушенного database constraint, перевалидировать и вернуть false. Таким образом, код пойдёт по ветке контроллера для ошибок валидации, и ошибка нарушенной уникальности отобразится обычными средствами на форме.</p>

<p>Я не проверяю, что вы выставили и валидацию, и индекс. За этим нужно следить самому.</p>

<p>Может, кому-то это окажется полезным. В любом случае, не оставляйте валидацию на уникальность в коде модели без поддержки уникального индекса в базе.</p>

<p><a href="https://github.com/dmitriy-kiriyenko/cerbero">Пользуйтесь!</a></p>

</div>

<a href="/v4/unique-validation.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Два пропущенных числа</h1>

<div>
  <p>Вашему вниманию <a href="https://gist.github.com/2834414">предлагалась задачка</a>, дабы не мозги не превращались в желе. На используемый язык ограничений не было. Главное, требовалось приложить инструкции для запуска. Победитель определялся по наименьшей сложности алгоритма. </p>

<p>Надо сказать, задачка была так себе, но в то же время, подумать было о чём.</p>

<p>Прежде всего хочется сказать спасибо всем, кто не остался в стороне. Повседневное решение чьих-то бытовых проблем - это не то, что привлекло нас в программирование и сердца наши полнятся радостью от осознания того, что мы не одиноки.</p>

<p>Традиционно отличился Андрей &quot;новичок в программировании&quot; Кутейко <a href="https://github.com/andy128k">andy128k</a> в нескольких номинациях:</p>

<ul>
<li><em>&quot;Первая ласточка&quot;</em> - его решение на питоне пришло первым.</li>
<li><em>&quot;Илита&quot;</em> - решение на Lisp.</li>
<li><em>&quot;Мыслитель&quot;</em> - есть решение для поиска N чисел.</li>
<li><em>&quot;По перед батька в пекло&quot;</em> - в Питоне есть необычная оптимизация для более эффективного (особенно по памяти) slice.</li>
<li><em>&quot;Не используй микроскоп&quot;</em> и <em>&quot;Шаман&quot;</em> - отдельное спасибо за решение на языке J.</li>
</ul>

<p><a href="https://github.com/zhck">Евгений Шелест</a> предложил итеративное решение для поиска двух со сложностью O(log(N)). Дмитрий Кириенко, конечно же, не мог остаться в стороне и предложил решение на Руби (совпадающее c Common Lisp решением Андрея на 100%) и на MySQL - там эта задача наименее надумана - поиск пропущенных идентификаторов. На MySQL, правда, вышло O(N) или даже хуже, но там вообще не до жиру. <a href="https://github.com/bronislav">Антон Ильин</a>, тоже предложил своё решение.</p>

<p>На десяти тысячах впереди всех питон, за ним лисп, два итеративных решения на Руби. MySQL - без комментариев. </p>

<p>Владимр Львович заставил нас взглянуть на проблему с другой стороны - а не получится ли понизить общую сложность до O(log(N)) при помощи бинарного поиска по файлу. К сожалению, его бинарный поиск не терминирован и в итоге выходит на линейную сложность, а как его терминировать я пока понять не могу. Может, что и никак. И за чертой контрольного срока предоставил своё решение, но решение это такое, что ему можно это простить. </p>

<p>Замеры производительности:</p>

<p><img src="http://i.minus.com/iZtzGhU3JivtL.png" alt=""><br>
</p>

<p>Несколько выводов.</p>

<ol>
<li>Безусловным победителем был объявлен Андрей Кутейко, понять бы ещё, что из этого вытекает. Надеемся, он хотя бы получил удовольствие =)</li>
<li>Иногда обобщение приводит к улучшению кода. Решения для двух чисел намного более уродливые, чем решения для N.</li>
<li>Соблюдая первое правило алгоритмиста - &quot;Can we do better?&quot; и благодаря Владимиру Львовичу мы взглянули на проблему с неожиданной стороны. Я ещё не уверен, что там нет полноценного логарифмического решения.</li>
<li>Используйте правильный инструмент. Предназначенный для обработки данных и особенно массивов, J, явил нам довольно красивое и аккуратное решение, которое в языках более общего назначения как минимум занимает больше букв.</li>
<li>Очень сложно программировать в SQL.</li>
</ol>

<p>Приз зрительский симпатий вручается Владимиру Львовичу, решение которого прошло за чертой смерти, но объективно было лучшим. Победа в следующих номинациях:</p>

<ul>
<li><em>&quot;А у вас была логарифмическая линейка?&quot;</em> - его решение единственное имеет честную логарифмическую сложность.</li>
<li><em>&quot;Свой среди чужих&quot;</em> - заметьте, решение написано на Руби, причём, с глубоким пониманием того, как работает, к примеру, класс &quot;File&quot;.</li>
<li><em>&quot;Обойдусь без записной книжки&quot;</em> - решение потребляет константную дополнительную память.</li>
<li><em>&quot;Сынки&quot;</em> - посмотрите на производительность.</li>
<li><em>&quot;Это же элементарно, Ватсон!&quot;</em> - решение не требует указания количества пропущенных чисел. Недостаток - не находит числа, пропущенные в конце. Но тут или то, или то.</li>
<li><em>&quot;Правый хвост длиннее&quot;</em> - интересный и математически обоснованный подход к проблеме бинарного поиска. <a href="https://gist.github.com/2834414#gistcomment-342948">Почитайте историю комментирования гиста</a> - это довольно интересно.</li>
<li><em>&quot;Чем докажешь&quot;</em> - оказаться правым в споре с Андреем Кутейко о программировании.</li>
</ul>

<p>Ждите новых разминок!</p>

<h2></h2>

<p>Дима и Леша.</p>

</div>

<a href="/v4/warm-up-two-missed.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Хеши: в поисках правды</h1>

<div>
  <p>Не знаю, для скольких это будет сюрпризом, но хэш-таблица, в отличие от, например, сбалансированного дерева, имеет вероятностное поведение. Она задумана как контейнер с операциями записать-прочитать-удалить по O(1) каждая, но на практике это не так.</p>

<p>На практике это Θ(1), то есть, в среднем и сбалансированном анализе это константа. В худшем случае это O(N).</p>

<p>Однако же, быстрая сортировка, применяемая в хвост и в гриву в библиотечных функциях (например, в bash-функции sort, в Array#sort в Руби, тысячи их), имеет сходные характеристики - несмотря на то, что он в большинстве случаев O(N*log(N)), в худших случаях он O(n^2), что ставит его на одну доску с пузырьком и делает асимптотически хуже той же сортировки слиянием. Но ведь в большинстве случаев используется именно он! А дело в том, что худшие случаи редки, а в сбалансированном случае он не только имеет хорошую алгоритмическую сложность, но и правильно расходует память и имеет чрезвычайно низкий коэффициент при этой самой &quot;тэте&quot;.</p>

<p>Теперь посмотрим на хэш-таблицы. Мы привыкли думать о операции вставки в хэш-таблицу как O(1), но это не так, поскольку на каком-то этапе нужно перевыделить память и в ходе этого выполняется rehash. Именно поэтому в приложениях, в требованиях к которым числится гарантированное время отклика, использование хэш-таблиц как структур хранения данных противопоказанно, или хотя бы требует осторожности, поскольку на очередной вставке всё может тупо подлагнуть и довольно сильно.</p>

<p>Однако же, давайте представим, что у нас не приложение, а вычислительный скрипт. Нам не важно время одной операции. Давайте посмотрим, как часто выполняется rehash. Вот принятие решения, делать или не делать rehash: <a href="https://github.com/ruby/ruby/blob/trunk/st.c#L487"><a href="https://github.com/ruby/ruby/blob/trunk/st.c#L487">https://github.com/ruby/ruby/blob/trunk/st.c#L487</a></a>. _Если среднее число записей в одной корзинке больше <a href="https://github.com/ruby/ruby/blob/trunk/st.c#L35">магического числа 5</a>_.  Новый же размер определяется <a href="https://github.com/ruby/ruby/blob/trunk/st.c#L151">ближайшими простыми числами к степеням двойки</a>. То есть, при вставке N элементов, будет выполнено O(log(N)) операций rehash. А каждый rehash (например, i-тый по счёту rehash) будет выполнен не на N элементах, а на простом числе, ближайшем к 2^i. В итоге, имеем сумму геометрической прогрессии с шагом 2, заканчивающейся на N/2. То есть, асимптотически, N.</p>

<p>Итого на N операций вставки имеем (N*O(1) + O(N)) вычислительную сложность.</p>

<p>Теперь с чтением из хэша. Тут сложнее и здесь асимптотически действительно всё плохо, потому что именно здесь вступает в силу то самое вероятностное поведение. Если, к примеру, реализовать хэш-функцию, как return 666, будем иметь ярко выраженную O(N) сложность на произвольный доступ. К счастью, так хэш-функцию никто не реализует.</p>

<p>Руби 1.8, 1.9 и 2.0 используют так называемый <a href="https://sites.google.com/site/murmurhash/">Murmur hash</a> (<a href="https://github.com/ruby/ruby/blob/trunk/st.c#L1252"><a href="https://github.com/ruby/ruby/blob/trunk/st.c#L1252">https://github.com/ruby/ruby/blob/trunk/st.c#L1252</a></a>). Этот алгоритм проходит &quot;<a href="http://burtleburtle.net/bob/hash/doobs.html">пыточный тест Боба Дженкинса</a>&quot; и не даёт коллизий на 4-х байтных ключах даже худшем случае. 4-х байтные ключи - это целые числа до двух миллиардов по модулю. В целом же, для любой разумной практической реализации верен тот факт, что коллизий немного. Конечно же, даже очень большое поле возможных хэшей для не очень большого подмножества значений будет давать коллизию с весьма высокой вероятностью. Так называемый <a href="http://en.wikipedia.org/wiki/Birthday_paradox">парадокс дней рождения</a>. Но одна коллизия - это в среднем пять операций (помните магическое число). А 1000 коллизий в Murmur hash случится и вовсе с вероятностью в миллиард раз меньшей, чем вероятность попадения метеора в ваш офис, если вероятность одной будет составлять аж 95%. </p>

<p>Таким образом, с любой разумной вероятностью стоимость извлечения из хэш-таблицы по ключу - константа. Редкие случаи коллизий во-первых, порождают, конечно, O(N), но Θ(1), а во-вторых невероятно редки.</p>

<p>Подвожу итог.</p>

<p>Хэш-таблица обладает серьёзными недостатками в производительности, не позволяющими использовать её в системах реального времени, там, где требуется <em>гарантированное</em> время отклика. Но в качестве структуры данных для реализации вычислительного алгоритма, операции вставки и произвольного доступа можно считать имеющими константную сложность.</p>

</div>

<a href="/v4/inside-the-hash.html" class="comment_link"><span>Comments</span></a>
</div>
  <div class="item">

<h1>Сумма двух - разбор полётов</h1>

<div>
  <p>Некоторое время назад общественности была предложена <a href="http://vecherka.cssum.net/v4/warm-up-sum-of-two.html">очередная разминка</a>, в которой предлагалось в массиве найти пару чисел, формирующих целевую сумму, или убедиться, что их нет. Ну, точнее, нужно было просто проверить, есть ли такие числа.</p>

<p>Последовавшая за этим дискуссия и всплеск решений были довольно интересны.</p>

<p>Первым обнаружился Артём Цаплин. <a href="https://gist.github.com/2948116">Его решение</a> - бинарный поиск с двух концов в упорядоченном массиве. Решение хорошее, но сортировку Артём применил свою, причём, это была сортировка вставкой, что тут же вывело его решение на квадратичную сложность.</p>

<p>Вторым в задаче отметился <a href="https://twitter.com/zocheg">Иван Трусов</a>, и отметился превосходно. Его решение во-первых, на чистом bash, а во-вторых довольно красивое. Он сортирует массив по хитрому критерию - так, чтобы числа, предположительно формирующие сумму, оказались рядом. Он перевёл своё решение на понятный нам руби - <a href="http://pastebin.com/SaBerWFF">прочитайте, не пожалеете</a>. Сложность очевидно равна сложности библиотечной сортировки - для быстрой сортировки это квадрат, но сбалансированная сложность N*log(N).</p>

<p>Два решения <a href="https://twitter.com/rbolgov">Романа Болгова</a> на javascript продолжают триумфальное разбирательство сообщества с задачей. <a href="https://gist.github.com/2950146">Первое</a> - использование хитрой структуры данных, известной как <a href="http://ru.wikipedia.org/wiki/%D0%91%D0%B8%D0%BD%D0%B0%D1%80%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE">двоичное дерево поиска</a>. <a href="https://gist.github.com/2950651">Второе</a> - использование хэш-таблицы для поиска пар чисел. Решение с хэш-таблицей - первое, которое имеет линейную сбалансированную сложность (в худшем случае мешают унизительные подробности реализации хэш-таблиц). Подробнее о хэш-таблицах, почему их применение, на мой взгляд, легитимно в этой задаче, и почему они всё же в худшем случае не дают нам O(N), можно прочитать в кратком обзоре <a href="http://vecherka.cssum.net/v4/inside-the-hash.html">Хеши: в поисках правды</a>. Решения весьма шустрые, в чём я подозреваю собственно, nodejs.</p>

<p>Далее в задаче обнаружился <a href="http://twitter.com/dudarev">Артём Дударев</a> с <a href="https://gist.github.com/b5fb033de085623d38fb">решением на python</a>, использующем hash set. Решение, надо сказать, самое шустрое из предложенных. Заслуга в этом очень быстрых питоновских хэшей (которые по скорости заметно обгоняют рубишные, впрочем, настолько же уступая им по использованию памяти.</p>

<p><a href="http://about.me/levzhinsky">Алексей Левжинский</a> тоже предложил два абсолютно идентичных решения - с хэшом и с разреженным массивом в качестве структуры данных. Здесь интересно то, что массив действительно единственная структура данных с честным константным произвольным доступом. В Ruby 2.0 хэши до 20 элементов будут внутри представлены массивом. Конечно, в решении Алексея совершенно сумашедший оверхед по памяти, но алгоритмически он прав. </p>

<p>Два решения от Владимира Львовича - сортировка и бинарный поиск второго слагаемого, и укладка в хэш и поиск по хэш-таблице второго слагаемого - завершили парад предложенных решений.</p>

<p>Замеры производительности:</p>

<pre><code>                        100000
================================
ruby tsaplin.rb          2.058
./trusov-coolsort.sh     0.359
ruby trusov_coolsort.rb  0.360
./trusov-hash.rb         0.330
node bolgovr_hash.js     0.322
node bolgovr_tree.js     0.343
python dudarev.py        0.232
ruby jinnsky_hash.rb     0.292
ruby jinnsky_array_rb    0.260
ruby raven29_binary.rb   0.459
ruby raven29_hash.rb     0.344
</code></pre>

<p>За неимением времени производительность измерялась так: на том же тестовом файле прогнал по 100 раз с разными искомыми числами и в результат пошли худшие случаи.</p>

<p>Номинации:</p>

<ul>
<li><em>Скор на ответ</em> - Артём Цаплин.</li>
<li><em>Самое быстрое решение</em> - Артём Дударев.</li>
<li><em>Порадовал</em> - Иван Борисович Трусов - за bash.</li>
<li><em>Почему бы и нет?</em> - Роман Болгов - за дерево.</li>
<li><em>Молодым везде у нас дорога</em> - Алексей Левжинский. Его решение на руби алгоритмически такое же, как и у всех, но заметно быстрее многих.</li>
<li><em>Тиграм не докладывают мяса</em> - Андрей Кутейко. За дискуссию про хэши.</li>
<li><em>Давайте сделаем это правильно</em> - Владимир Львович Коварский. За самотестирующийся скрипт. Дима и Андрей прошлый раз все свои решения сопровождали встроенными тестами, но послание воспринял только Владимир Львович.</li>
</ul>

<p>Несколько выводов:</p>

<ul>
<li>Разминки - замечательная штука. Перед публикацией было найдено только два из предложенных решений и сообщество нашло еще три других.</li>
<li>Уже к середине недели задача была порвана в клочья и мы рассуждали о тонкостях использования структур данных.</li>
<li>Язык реализиции слабо влияет на проиводительность. Никакие микрооптимизации не сделают сортировку вставкой быстрее поиска по хэш-таблице, а решения одинаковые концептуально, будут очень близки по скорости работы.</li>
<li>Очень много нового можно узнать, копнув где угодно. Час внутри реализации рубишных хэшей <a href="http://vecherka.cssum.net/v4/inside-the-hash.html">дали ответы</a> на множество незаданных вопросов.</li>
<li>Bash - довольно лаконичный язык программирования. Элегантные однострочники от Ивана Трусова и компактны и читаемы.</li>
</ul>

<p>Спасибо всем кто участвовал.</p>

</div>

<a href="/v4/sum-of-the-two-result.html" class="comment_link"><span>Comments</span></a>
</div>
</div>

<div class="clearfix"></div>
<div class="right">
  <div class="item quotes">

<h1>С моих слов записано верно и мною прочитано. Претензий не имею</h1>

<div>
  <p><img src="http://i.minus.com/ilZfarZP53RTB.png" alt=""><br>
</p>

<ul>
<li>«Есть два подхода к программированию. Первый — сделать программу настолько простой, чтобы в ней очевидно не было ошибок. А второй — сделать её настолько сложной, чтобы в ней не было очевидных ошибок.» <em>Чарльз Энтони Ричард Хоар. Профессор, занимался реализацией Алгол 60, сейчас исследователь в Microsoft Research.</em></li>
<li>«Objective C был значительно лучше, пока я его не использовал» <em>Дмитрий Кириенко</em></li>
<li>«Если отладка — процесс удаления ошибок, то программирование должно быть процессом их внесения» <em>Эдсгер Вайб Дейкстра</em></li>
<li>«Сделай так просто, как возможно, но не проще этого.» <em>Альберт Энштейн</em></li>
</ul>

</div>

<a href="/v4/v4-quotes.html" class="comment_link"><span>Comments</span></a>
</div>
</div>

<div class="clearfix"></div>





    </div>
  </section>

  <span id="empty_footer"></span>
  <footer>
    <div class="wrapper">
      <a href="https://twitter.com/it_vecherka" class="twitter-follow-button" data-show-count="false" data-lang="ru" data-show-screen-name="false">Читать @it_vecherka</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

      <div class="copyright"><div>&copy;&nbsp;<strong>Вечерний Анахорет&trade;</strong></div>
<div><small>Все права защищены кольчугой из&nbsp;чешуи дракона +3</small></div>
<div><small>Предложения и&nbsp;замечания <a href="mailto:vecherka@cssum.net">шлите редактору</a>.</small></div>

</div>

    </div>
  </footer>
</div>
<!-- Yandex.Metrika counter -->
<div style="display:none;"><script type="text/javascript">
(function(w, c) {
    (w[c] = w[c] || []).push(function() {
        try {
            w.yaCounter10762477 = new Ya.Metrika({id:10762477, enableAll: true});
        }
        catch(e) { }
    });
})(window, "yandex_metrika_callbacks");
</script></div>
<script src="//mc.yandex.ru/metrika/watch.js" type="text/javascript" defer="defer"></script>
<noscript><div><img src="//mc.yandex.ru/watch/10762477" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</body>
</html>
